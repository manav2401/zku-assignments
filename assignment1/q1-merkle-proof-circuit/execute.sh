#!/bin/bash

## Compile the circuit and obtain programs to compute the witness.
echo "Compiling merkle_proof.circom circuit"

## Compile the circuit
# -r1cs generates `merkle_proof.r1cs` (the r1cs constraint system of the circuit in binary format)
# --wasm generates `merkle_proof.wasm` (the wasm code that can be used to generate witness)
# --c generates `merkle_proof.c` (the c code that can be used to generate witness)
# --sym generated `merkle_proof.sym` (a symbols file required for debugging and printing the constraint system in an annotated mode)
circom merkle_proof.circom --r1cs --wasm --c --sym

## Computing the witness with WebAssembly
# Using an input file, which contains the inputs to be provided to the circuit, 
# we need a witness: a set of signals that satisfy the circuit.
# We will use the JS and WASM generated files by the above command to generate witness 
# Input file: input.json, output file: witness.wtns
# The two programs will generate the same ẁitness.wtns file. 
# This file is encoded in a binary format compatible with snarkjs, which is the tool that we use to create the actual proofs. 
cd merkle_proof_js/
node generate_witness.js merkle_proof.wasm ../input.json witness.wtns
cd ..

## Trusted setup generation
# In order to generate a zk-proof, we need to generate a trusted setup using a zk-SNARK protocol, called Groth16.
# The trusted setup involves a ceremony, where people agree to some source of randomness, which is required
# to generate the proof. It takes place in 2 phases. 

## Phase-1: Generation of "Powers of Tau". 
# It starts the ceremony and is independent of the circuit itself.
# The power of tau should be high enough to run phase-2, otherwise will get an error of the from "X > 2^n".
echo "Starting phase-1"
echo "Creating the tau ceremony"
snarkjs powersoftau new bn128 14 pot12_0000.ptau -v
echo "Making the first contribution tau ceremony"
snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="First contribution" -v -e="manav"

## Phase 2: Generate the proving and verification keys
# This phase is circuit-specific and is used to generate a .zkey file.
echo "Starting phase-2"
snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v
snarkjs groth16 setup merkle_proof.r1cs pot12_final.ptau merkle_proof_0000.zkey

echo "Making the contribution tau ceremony"
snarkjs zkey contribute merkle_proof_0000.zkey merkle_proof_0001.zkey --name="1st Contributor Name" -v -e="manav"
snarkjs zkey export verificationkey merkle_proof_0001.zkey verification_key.json

cp merkle_proof_js/witness.wtns .

## Proof generation
# Generate a zk-proof using the witnes and key generated by the trusted setup.
echo "Generating Proof"
snarkjs groth16 prove merkle_proof_0001.zkey witness.wtns proof.json public.json

## Proof verification
# Verify the zk-proof by providing the public.json file
# This generates the proof in proof.json file
echo "Verifying Proof"
snarkjs groth16 verify verification_key.json public.json proof.json

## Generate a smart contract, which can be used to verify the proof
snarkjs zkey export solidityverifier merkle_proof_0001.zkey verifier.sol
echo "Generated smart contract for proof verification: verifier.sol"

## In order to verify against the contract function, generate the valid input params
snarkjs generatecall
echo "Parameters for smart contract generated"
